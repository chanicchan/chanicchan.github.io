<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Grader: Handwritten MCQ</title>
    <script src='https://unpkg.com/tesseract.js@v2.1.0/dist/tesseract.min.js'></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f3f4f6; user-select: none; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Camera View */
        #camera-wrapper {
            position: relative;
            width: 100%;
            max-width: 640px;
            min-height: 320px; 
            margin: 0 auto;
            background: #000;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* This crops the video */
            opacity: 0.9;
        }
        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Alignment Status Badge */
        .status-badge {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        .status-text { font-weight: 600; }
        
        .indicator-dot { width: 10px; height: 10px; border-radius: 50%; background: #ef4444; transition: background 0.2s; }
        .indicator-dot.ready { background: #eab308; box-shadow: 0 0 5px #eab308; }
        .indicator-dot.active { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Navigation -->
    <nav class="bg-indigo-600 text-white p-3 shadow-md shrink-0">
        <div class="max-w-md mx-auto flex justify-between items-center">
            <h1 class="text-lg font-bold tracking-tight">üìù QuickGrade Live</h1>
            <div class="flex text-xs font-semibold bg-indigo-800 rounded-lg p-1">
                <button onclick="switchTab('key')" id="nav-key" class="px-3 py-1 rounded hover:bg-indigo-600">Key</button>
                <button onclick="switchTab('scan')" id="nav-scan" class="px-3 py-1 rounded bg-indigo-500">Scan</button>
                <button onclick="switchTab('stats')" id="nav-stats" class="px-3 py-1 rounded hover:bg-indigo-600">Stats</button>
            </div>
        </div>
    </nav>

    <main class="flex-grow relative overflow-y-auto">
        
        <!-- TAB 1: ANSWER KEY -->
        <div id="tab-key" class="tab-content p-4 max-w-md mx-auto">
            <div class="bg-white p-4 rounded-lg shadow">
                <h2 class="font-bold mb-2 text-gray-800">Answer Key Setup</h2>
                <div class="grid grid-cols-5 gap-2 mb-4" id="key-grid"></div>
                <button onclick="switchTab('scan')" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-bold shadow">
                    Ready to Scan ‚Üí
                </button>
            </div>
        </div>

        <!-- TAB 2: SCANNER -->
        <div id="tab-scan" class="tab-content active p-2 max-w-md mx-auto h-full flex flex-col">
            
            <!-- Camera Section -->
            <div id="camera-wrapper">
                <video id="video" autoplay playsinline></video>
                <canvas id="overlay-canvas"></canvas>
                
                <!-- Overlay UI -->
                <div class="status-badge" id="status-badge">
                    <div id="status-dot" class="indicator-dot"></div>
                    <span id="scan-status-text" class="status-text">Start Camera</span>
                </div>
            </div>

            <!-- Controls -->
            <div class="mt-3 grid grid-cols-2 gap-3 shrink-0">
                <button id="btn-toggle-cam" onclick="toggleCamera()" class="bg-gray-700 text-white py-3 rounded-lg font-bold shadow flex justify-center items-center gap-2 text-sm">
                    üì∑ Toggle Cam
                </button>
                <button id="btn-reset" onclick="resetCurrentScan()" class="bg-red-100 text-red-600 py-3 rounded-lg font-bold shadow text-sm">
                    ‚Ü∫ Reset
                </button>
            </div>

            <!-- Progress Bar -->
            <div class="mt-4 bg-white p-3 rounded-lg shadow shrink-0">
                <div class="flex justify-between text-xs mb-1 font-bold text-gray-500 uppercase">
                    <span>Scan Progress</span>
                    <span id="progress-text">0/15</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>

            <!-- Live Results Grid -->
            <div class="mt-3 flex-grow overflow-y-auto bg-white rounded-lg shadow p-3">
                <h3 class="text-xs font-bold text-gray-400 uppercase mb-2">Results</h3>
                <div id="live-results" class="grid grid-cols-5 gap-2">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Save Button -->
            <button id="btn-save" onclick="saveStudent()" class="mt-3 w-full bg-green-600 text-white py-3 rounded-lg font-bold shadow disabled:opacity-50 disabled:grayscale" disabled>
                ‚úÖ Save Result
            </button>
        </div>

        <!-- TAB 3: STATISTICS -->
        <div id="tab-stats" class="tab-content p-4 max-w-md mx-auto">
            <div class="grid grid-cols-2 gap-3 mb-4">
                <div class="bg-blue-100 p-4 rounded-lg text-center">
                    <div class="text-3xl font-bold text-blue-700" id="stat-total">0</div>
                    <div class="text-xs text-blue-600 font-bold uppercase">Papers</div>
                </div>
                <div class="bg-green-100 p-4 rounded-lg text-center">
                    <div class="text-3xl font-bold text-green-700" id="stat-avg">0%</div>
                    <div class="text-xs text-green-600 font-bold uppercase">Average</div>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <table class="w-full text-sm text-left">
                    <thead class="bg-gray-50 text-gray-500">
                        <tr>
                            <th class="px-4 py-2">ID</th>
                            <th class="px-4 py-2">Score</th>
                            <th class="px-4 py-2">%</th>
                        </tr>
                    </thead>
                    <tbody id="stats-list"></tbody>
                </table>
            </div>
        </div>

        <!-- Worker Canvas (Hidden) -->
        <canvas id="worker-canvas" class="hidden"></canvas>
        <!-- Alignment Check Canvas (Hidden) -->
        <canvas id="align-canvas" class="hidden"></canvas>
    </main>

    <script>
        // --- Config ---
        const TOTAL_Q = 15;
        const LAYOUT = [];
        for(let i=0; i<10; i++) LAYOUT.push({id: i+1, r:0, c:i});
        for(let i=0; i<5; i++) LAYOUT.push({id: i+11, r:1, c:i});

        // --- State ---
        let state = {
            answers: new Array(TOTAL_Q).fill(null),
            key: new Array(TOTAL_Q).fill('A'),
            isScanning: false,
            isAligned: false,
            stream: null,
            worker: null,
            queue: [],
            processing: false
        };
        let classData = [];

        // --- Init ---
        window.onload = async () => {
            initKeyUI();
            renderLiveGrid();
            
            state.worker = Tesseract.createWorker({ logger: m => {} });
            await state.worker.load();
            await state.worker.loadLanguage('eng');
            await state.worker.initialize('eng');
            await state.worker.setParameters({ tessedit_char_whitelist: 'ABCD' });
            console.log("OCR Worker Ready");
        };

        function switchTab(t) {
            document.querySelectorAll('.tab-content').forEach(e => e.classList.remove('active'));
            document.getElementById('tab-'+t).classList.add('active');
            ['key','scan','stats'].forEach(n => {
                const btn = document.getElementById('nav-'+n);
                btn.className = n===t ? "px-3 py-1 rounded bg-indigo-500" : "px-3 py-1 rounded hover:bg-indigo-600";
            });
        }

        // --- UI Generators ---
        function initKeyUI() {
            const grid = document.getElementById('key-grid');
            grid.innerHTML = state.key.map((k, i) => `
                <div class="flex flex-col">
                    <label class="text-[10px] font-bold text-gray-400 text-center">${i+1}</label>
                    <select onchange="state.key[${i}]=this.value" class="border rounded text-center text-sm p-1 bg-gray-50">
                        ${['A','B','C','D'].map(opt => `<option ${k===opt?'selected':''}>${opt}</option>`).join('')}
                    </select>
                </div>
            `).join('');
        }

        function renderLiveGrid() {
            const grid = document.getElementById('live-results');
            grid.innerHTML = state.answers.map((ans, i) => {
                const isDone = ans !== null;
                const color = isDone ? 'bg-green-100 border-green-500 text-green-800' : 'bg-gray-50 border-gray-200 text-gray-300';
                return `
                    <div onclick="manualEdit(${i})" class="border-2 rounded p-2 text-center cursor-pointer transition-all ${color}">
                        <div class="text-[10px] font-bold mb-1">Q${i+1}</div>
                        <div class="text-xl font-bold h-6 leading-none">${ans || '?'}</div>
                    </div>
                `;
            }).join('');
            
            const doneCount = state.answers.filter(a => a).length;
            document.getElementById('progress-text').innerText = `${doneCount}/${TOTAL_Q}`;
            document.getElementById('progress-bar').style.width = `${(doneCount/TOTAL_Q)*100}%`;
            document.getElementById('btn-save').disabled = doneCount === 0;
        }

        function manualEdit(idx) {
            const val = prompt(`Edit Question ${idx+1}`, state.answers[idx] || "");
            if(val && "ABCD".includes(val.toUpperCase())) {
                state.answers[idx] = val.toUpperCase();
                renderLiveGrid();
            }
        }

        // --- Camera & Loop ---
        async function toggleCamera() {
            if(state.stream) {
                state.stream.getTracks().forEach(t => t.stop());
                state.stream = null;
                state.isScanning = false;
                updateStatus("Camera Offline", "off");
            } else {
                try {
                    state.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment", width: {ideal: 1920} } });
                    const vid = document.getElementById('video');
                    vid.srcObject = state.stream;
                    vid.onloadedmetadata = () => {
                        state.isScanning = true;
                        updateStatus("Align Corners", "ready");
                        refillQueue();
                        requestAnimationFrame(scanLoop);
                    };
                } catch(e) {
                    alert("Camera Error: " + e.message);
                }
            }
        }

        function resetCurrentScan() {
            state.answers.fill(null);
            renderLiveGrid();
            refillQueue();
        }

        function refillQueue() {
            state.queue = state.answers.map((a, i) => a === null ? i : -1).filter(i => i !== -1);
        }

        function scanLoop() {
            if(!state.isScanning) return;

            // 1. Draw & Check Alignment
            const aligned = processAlignmentAndOverlay();
            state.isAligned = aligned;

            // 2. Update Status UI
            if(aligned) {
                updateStatus("Scanning...", "active");
            } else {
                updateStatus("Align Markers", "ready");
            }

            // 3. Process OCR if aligned
            if(aligned && !state.processing && state.queue.length > 0) {
                processNextInQueue();
            }

            requestAnimationFrame(scanLoop);
        }

        function updateStatus(text, type) {
            const txt = document.getElementById('scan-status-text');
            const dot = document.getElementById('status-dot');
            const badge = document.getElementById('status-badge');
            
            if(txt.innerText !== text) txt.innerText = text;
            dot.className = `indicator-dot ${type}`;
            
            if(type === 'active') badge.style.border = "1px solid #4ade80"; 
            else badge.style.border = "none";
        }

        // --- COORDINATE MAPPING (Crucial Fix) ---
        function mapToSource(vid, cvsX, cvsY, cvsW, cvsH) {
            // Correctly maps canvas coordinates to video source coordinates 
            // accounting for object-fit: cover
            
            const vidW = vid.videoWidth;
            const vidH = vid.videoHeight;
            const viewW = vid.clientWidth;
            const viewH = vid.clientHeight;

            const vidRatio = vidW / vidH;
            const viewRatio = viewW / viewH;

            let renderW, renderH, offsetX, offsetY;

            if (vidRatio > viewRatio) {
                // Video is wider: Height matches, Width cropped (sides)
                renderH = viewH;
                renderW = viewH * vidRatio;
                offsetY = 0;
                offsetX = (renderW - viewW) / 2;
            } else {
                // Video is taller: Width matches, Height cropped (top/bottom)
                renderW = viewW;
                renderH = viewW / vidRatio;
                offsetX = 0;
                offsetY = (renderH - viewH) / 2;
            }
            
            const scale = vidH / renderH; // Scaling factor

            // Map
            const sourceX = (cvsX + offsetX) * scale;
            const sourceY = (cvsY + offsetY) * scale;
            const sourceW = cvsW * scale;
            const sourceH = cvsH * scale;

            return { x: sourceX, y: sourceY, w: sourceW, h: sourceH };
        }

        // --- Alignment & Overlay ---
        function processAlignmentAndOverlay() {
            const vid = document.getElementById('video');
            const cvs = document.getElementById('overlay-canvas');
            const ctx = cvs.getContext('2d');

            if(cvs.width !== vid.clientWidth) {
                cvs.width = vid.clientWidth;
                cvs.height = vid.clientHeight;
            }

            const w = cvs.width;
            const h = cvs.height;
            ctx.clearRect(0,0,w,h);

            const margin = 30;
            const gridW = w - (margin*2);
            const cellW = gridW / 10; 
            const cellH = cellW;      
            const gridH = cellH * 2;  
            
            const startX = margin;
            const startY = (h - gridH) / 2;

            // Marker Config
            const markerSize = cellW * 0.35; 
            const markerOffset = cellW * 0.5; 
            
            const anchors = [
                {x: startX - markerOffset, y: startY - markerOffset}, 
                {x: startX + gridW + markerOffset - markerSize, y: startY - markerOffset}, 
                {x: startX - markerOffset, y: startY + gridH + markerOffset - markerSize}, 
                {x: startX + gridW + markerOffset - markerSize, y: startY + gridH + markerOffset - markerSize} 
            ];

            const alignCtx = document.getElementById('align-canvas').getContext('2d', {willReadFrequently: true});
            
            let allAnchorsLocked = true;

            anchors.forEach(anc => {
                ctx.strokeStyle = state.isAligned ? '#22c55e' : '#ef4444';
                ctx.lineWidth = 2;
                ctx.strokeRect(anc.x, anc.y, markerSize, markerSize);
                
                // Center Sample
                const sampleW = markerSize * 0.5;
                const sampX = anc.x + markerSize/2 - sampleW/2;
                const sampY = anc.y + markerSize/2 - sampleW/2;

                // USE CORRECT MAPPING
                const src = mapToSource(vid, sampX, sampY, sampleW, sampleW);
                
                try {
                    alignCtx.drawImage(vid, src.x, src.y, src.w, src.h, 0, 0, 1, 1);
                    const pixel = alignCtx.getImageData(0, 0, 1, 1).data;
                    const brightness = (pixel[0] + pixel[1] + pixel[2]) / 3;
                    
                    const isDark = brightness < 160;
                    
                    if(isDark) {
                        ctx.fillStyle = 'rgba(34, 197, 94, 0.5)'; 
                        ctx.fillRect(anc.x, anc.y, markerSize, markerSize);
                    } else {
                        allAnchorsLocked = false;
                    }
                } catch(e) { allAnchorsLocked = false; }
            });

            if(allAnchorsLocked) {
                ctx.strokeStyle = '#22c55e'; 
            } else {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; 
            }
            
            LAYOUT.forEach((box, i) => {
                const x = startX + box.c * cellW;
                const y = startY + box.r * cellH;
                
                const isScanned = state.answers[i] !== null;
                const isProcessing = state.processingIdx === i;

                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, cellW, cellH);

                if(isScanned) {
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.4)';
                    ctx.fillRect(x, y, cellW, cellH);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(state.answers[i], x + cellW/2, y + cellH/1.6);
                } else if(isProcessing && allAnchorsLocked) {
                    ctx.strokeStyle = '#eab308'; 
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x+2, y+2, cellW-4, cellH-4);
                }
            });

            return allAnchorsLocked;
        }

        // --- AI Logic ---
        async function processNextInQueue() {
            if(!state.worker) return;
            
            const idx = state.queue.shift(); 
            state.processing = true;
            state.processingIdx = idx;

            try {
                const vid = document.getElementById('video');
                const workCvs = document.getElementById('worker-canvas');
                const workCtx = workCvs.getContext('2d');
                const dispCvs = document.getElementById('overlay-canvas');
                
                const margin = 30;
                const w = dispCvs.width;
                const h = dispCvs.height;
                const gridW = w - (margin*2);
                const cellW = gridW / 10;
                const cellH = cellW; 
                const gridH = cellH * 2;
                const startX = margin;
                const startY = (h - gridH) / 2;

                const boxData = LAYOUT[idx];
                const px = cellW * 0.15; 
                
                const canvasCropX = startX + boxData.c * cellW + px;
                const canvasCropY = startY + boxData.r * cellH + px;
                const canvasCropW = cellW - px*2;
                const canvasCropH = cellH - px*2;

                // USE CORRECT MAPPING
                const src = mapToSource(vid, canvasCropX, canvasCropY, canvasCropW, canvasCropH);

                workCvs.width = src.w;
                workCvs.height = src.h;
                
                workCtx.filter = 'contrast(1.4) grayscale(1)';
                workCtx.drawImage(vid, src.x, src.y, src.w, src.h, 0, 0, src.w, src.h);

                const res = await state.worker.recognize(workCvs.toDataURL());
                
                const confidence = res.data.confidence;
                const char = cleanChar(res.data.text);

                if(char && confidence > 65) {
                    state.answers[idx] = char;
                    renderLiveGrid();
                } else {
                    state.queue.push(idx); // Retry later
                }

            } catch(e) {
                state.queue.push(idx);
            }

            state.processing = false;
            state.processingIdx = -1;
        }

        function cleanChar(text) {
            const t = text.toUpperCase();
            if(t.includes('A')) return 'A';
            if(t.includes('B') || t.includes('8')) return 'B';
            if(t.includes('C') || t.includes('(') || t.includes('G')) return 'C';
            if(t.includes('D') || t.includes('0') || t.includes('O')) return 'D';
            return null;
        }

        // --- Save & Stats ---
        function saveStudent() {
            let score = 0;
            state.answers.forEach((a, i) => { if(a === state.key[i]) score++; });
            const sObj = { id: classData.length+1, score };
            classData.push(sObj);
            
            document.getElementById('stat-total').innerText = classData.length;
            const avg = classData.reduce((a,b)=>a+b.score,0) / classData.length;
            document.getElementById('stat-avg').innerText = Math.round((avg/TOTAL_Q)*100) + '%';
            
            const row = `<tr class="bg-white border-b"><td class="px-4 py-2">#${sObj.id}</td><td class="px-4 py-2">${score}</td><td class="px-4 py-2">${Math.round((score/TOTAL_Q)*100)}%</td></tr>`;
            document.getElementById('stats-list').innerHTML += row;

            resetCurrentScan();
            alert(`Saved! Score: ${score}/${TOTAL_Q}`);
        }
    </script>
</body>
</html>